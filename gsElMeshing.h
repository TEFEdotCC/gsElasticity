/** @file gsElMeshing.h

    @brief Provides isogeometric meshing and modelling routines.

    This file is part of the G+Smo library.

    This Source Code Form is subject to the terms of the Mozilla Public
    License, v. 2.0. If a copy of the MPL was not distributed with this
    file, You can obtain one at http://mozilla.org/MPL/2.0/.

    Author(s):
        A.Shamanskiy (2016 - ...., TU Kaiserslautern)
*/

#pragma once

#include <gsCore/gsMultiPatch.h>

namespace gismo
{

//-----------------------------------//
//--------- Mesh deformation --------//
//-----------------------------------//

/// @brief Deforms a given domain iteratively using linear elasticity so that its
/// boundary coincides with with a given boundary; returns a set of deformation
/// coefficients for every incremental steps for every patch
template <class T>
void computeDeformationInc(std::vector<std::vector<gsMatrix<T> > > & result,
                           gsMultiPatch<T> const & domain, gsBoundaryConditions<T> const & bdry,
                           int numSteps = 3, T poissonRatio = 0.49);

/// @brief Deforms a given domain iteratively using linear elasticity so that its
/// boundary coincides with with a given boundary; returns a set of deformation
/// coefficients for every incremental steps for every patch
template <class T>
void deformNonLinearly(gsMultiPatch<T> & result, gsMultiPatch<T> const & domain,
                       std::vector<std::vector<gsMatrix<T> > > const & deformation,
                       gsMatrix<T> const & sumSolutionVector,
                       gsBoundaryConditions<T> const & bdry, T poissonRatio = 0.49,
                       T tolerance = 1e-12, int maxNumIterations = 20);

/// @brief Visualizes the mesh deformation coeffs <result> computed using the <deform> function;
/// set <plotJac> to plot the Jacobian of the mesh using <numSamples> points
template <class T>
void plotDeformation(std::vector<std::vector<gsMatrix<T> > > const & result,
                     gsMultiPatch<T> const & domain, std::string fileName,
                     bool plotJac = false, int numSamples = 1);

/// @brief Deformes the initial domain using <deformation>
template <class T>
void applyDeformation(std::vector<std::vector<gsMatrix<T> > > const & deformation,
                      gsMultiPatch<T> const & initDomain, gsMultiPatch<T> & domain);

/// @brief Returns min(Jacobian determinant) divided by max(Jacobian determinant)
template <class T>
T measureMinMaxJ(gsMultiPatch<T> const & domain, int numSamples = 10000);

/// @brief Constructs intermidiate configurations by scaling the deformation
/// and estimates their quality based on the Jacobian measure;
/// the results are written to a .txt file to be plotted in Matlab
template <class T>
void analyzeDeformation(std::vector<std::vector<gsMatrix<T> > > const & deformation,
                        gsMultiPatch<T> const & domain, int measPerStep,
                        std::string fileName, int numSamples = 10000);

//-----------------------------------//
//----------- Modelling--------------//
//-----------------------------------//

/// @brief generates a simplified curve by fitting with the coarsest basis of the same degree;
/// then reparametrizes it using the basis of the original curve;
/// <additionalPoints> increases the number of degrees of freedom;
/// <numSamples> is a number of sampling points for reparametrization
template<class T>
typename gsGeometry<T>::uPtr simplifyCurve(gsGeometry<T> const & curve,
                                          int additionalPoints = 0, int numSamples = 1000);

/// @brief fits a given parametrized point cloud with a curve using a given basis;
/// the resulting curve interpolates the first and the last points
template <class T>
typename gsGeometry<T>::uPtr fittingDirichlet(gsMatrix<T> const & params,
                                              gsMatrix<T> const & points,
                                              gsBasis<T> const & basis);

/// @grief generates a tensor product B-spline patch by interpolating between the two given B-spline patches
/// of a dimension one lower;
/// in 2D case, interpolates in eta/south-north direction by default;
/// in 3D case, always interpolates in the third direction/front-back
template<class T>
typename gsGeometry<T>::uPtr genPatchInterpolation(gsGeometry<T> const & A, gsGeometry<T> const & B,
                                                   int deg, int num, bool xiDir = false);

/// @brief generates a tensor product B-spline    bdry   south | front
/// patch by scaling a given geometry object      \  /     |   |   |
/// towards a given center point;                 (x,y)  north |  back
/// oppositely lying bdry is generated by scaling the original boundary with <scaling> coeff
template<class T>
typename gsGeometry<T>::uPtr genPatchScaling(gsGeometry<T> const & boundary,
                                             int deg, int num,
                                             T scaling, gsVector<T> const & center);

/// @breif generates a uniformly parametrized straight line with a B-spline basis;
/// end points are given as ROWS of matrices
template<class T>
typename gsGeometry<T>::uPtr genLine(int deg, int num,
                                     gsMatrix<T> const & A, gsMatrix<T> const & B,
                                     int iA = 0, int iB = 0);

/// @breif generates a uniformly parametrized circular arc with a B-spline basis;
/// generates a closed circle if <arcAngle> is 2pi
template<class T>
typename gsGeometry<T>::uPtr genCircle(int deg, int num,
                                      T radius = 1., T x0 = 0., T y0 = 0.,
                                      T angle0 = 0., T arcAngle = 2*M_PI);

/// @breif generates a uniformly parametrized circular arc with a given basis;
/// generates a closed circle if <arcAngle> is 2pi
template<class T>
typename gsGeometry<T>::uPtr genCircle(gsBasis<T> & basis,
                                       T radius = 1., T x0 = 0., T y0 = 0.,
                                       T angle0 = 0., T arcAngle = 2*M_PI);

/// @brief generates a quad patch given by its four   C---D
/// corners with the following orientation;           |   |
/// the points are given as ROWS of matrices          A---B
template<class T>
typename gsGeometry<T>::uPtr genQuad(int xiDeg, int xiNum, int etaDeg, int etaNum,
                                     gsMatrix<T> const & A, gsMatrix<T> const & B,
                                     gsMatrix<T> const & C, gsMatrix<T> const & D,
                                     int iA = 0, int iB = 0, int iC = 0, int iD = 0);

/// @brief generates a tensor product B-spline spherical patch with radius 1 and center at 0
/// given the degrees and number of control points in two parametric dimensions
template<class T>
typename gsGeometry<T>::uPtr genSphere(int xiDeg, int xiNum, int etaDeg, int etaNum,
                                       T xi0 = 0., T xi1 = 2*M_PI,
                                       T eta0 = -M_PI/2, T eta1 = M_PI/2);

/// @brief generates a tensor product B-spline spherical patch with radius 1 and center at 0
/// given knot vectors for two parametric dimensions
template<class T>
typename gsGeometry<T>::uPtr genSphere(gsKnotVector<T> & xiKnots, gsKnotVector<T> & etaKnots,
                                       T xi0 = 0., T xi1 = 2*M_PI,
                                       T eta0 = -M_PI/2, T eta1 = M_PI/2);

/// @brief generates a 3D tensor product B-spline cylindrical patch
template<class T>
typename gsGeometry<T>::uPtr genCylinder(gsGeometry<T> const & base,
                                         int deg, int num, T height);

/// @brief generates a 3D tensor product B-spline screw-like patch
template<class T>
typename gsGeometry<T>::uPtr genScrew(gsGeometry<T> const & base,
                                      int deg, int num,
                                      T height, T pitch, T x0 = 0., T y0 = 0.);

//----------------------------------------//
//----------- Auxiliary functions --------//
//----------------------------------------//

/// @brief compute a convex combintation (1-x)a+xb
template<class T>
inline T combine(T a, T b, T x) { return a*(1-x)+b*x; }

/// @brief compute a convex combination of two points given as ROWS
/// of matrices numbered <iA> and <iB>;
/// set <cols> to <true> to give points as COLUMNS
template<class T>
gsMatrix<T> combine(gsMatrix<T> const & A, gsMatrix<T> const & B, T x,
                    int iA = 0, int iB = 0, bool cols = false);

/// @brief compute a distance between the point number <i> in the set <A>
/// and the point number <j> in the set <B>;
/// by default, points are given as ROWS of matrices;
/// set <cols> to <true> to give points as COLUMNS
template <class T>
T distance(gsMatrix<T> const & A, gsMatrix<T> const & B,
           index_t i = 0, index_t j = 0, bool cols = false);

} // namespace ends
